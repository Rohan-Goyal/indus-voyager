#+OPTIONS: toc:nil title:nil author:nil
#+LANGUAGE: en
#+AUTHOR: Rohan Goyal
#+TITLE: Internship Report: Simulating a Voyager 3 Mission
#+begin_export latex
\begin{titlepage}
\begin{center}
{\Large Internship Report \par}
\vspace{2cm}
{\Large Simulating a Voyager 3 Mission\par}
\vspace{2cm}
Report prepared for Team Indus
\vfill
{\large Rohan Goyal \par}
{\large Summer 2021}
\end{center}
\end{titlepage}
  \tableofcontents \clearpage
#+end_export
#+LATEX_HEADER: \usepackage[none]{hyphenat}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{setspace}
* Introduction
** Task Description
My overarching task was to design and simulate a `Voyager 3' mission, which would launch around 2024-2025 and visit as many of the outer planets as possible.
** Methodology
I began by exploring the theory behind deep-space missions like this one. I looked at the mechanics of gravity assist maneuvers to change velocity/direction, such as how they're used to achieve high delta-V without using large amounts of propellant.

I also researched mathematical models of these maneuvers such as numerical solutions to Lambert's Problem (also known as the orbital boundary value problem), which deals with determining a transfer orbit between two known orbits (in the form of position and velocity vectors), given a target value for the time of flight. This included looking into the method of patched conics, which models a three-body gravity assist problem as a set of two-body problems, and defines a set of `patch conditions' which connect the solutions to individual two-body problems into a single trajectory.

My first experimental step was to design and verify a simulation of the Voyager 2 mission, based on the historical flight data. This would allow me to test my approach to modelling by cross-checking it with established data, before using it to simulate a completely new mission.
Based on this, I ended up doing additional research into the specific design of Voyager 2 and its mission planning, such as the Trajectory Correction Maneuvers voyager relied on to stay on course and compensate for unexpected fluctuations.

With this done, I wrote some scripts to plot the planets over time, to get an idea of feasible mission plans for 2024. I learned that Saturn was out of alignment with the other outer planets, and so Voyager 3 would only be able to visit Jupiter, Uranus, and Neptune.
** What I Learned
I learned a lot about the costs/trade-offs of almost everything in deep space missions. Gravity assists introduce new complexities and constraints, even as they decrease the need for large delta-V budgets. The need for gravity assists restricts the paths an object can take through space, and forces us to plot trajectories around entry/exit angles of these maneuvers.

Relatedly, I learned about the need for precision in mission planning. My initial simulations (lacking correction maneuvers) showed me how small errors in the trajectory can snowball out of control over time. Reading the orbit reconstruction papers, and looking at the level of detail involved in the modelling, also helped me understand how important seemingly insignificant details like thruster imperfections were to mission planning and orbit determination.

I also learned about mathematical formulations of physical problems, and how deceptively simple problems can have complex solutions. The Lambert problem is stated (in it's simplest form) as a boundary value problem (differential equation with constraints) that relates the acceleration of a body to it's direction relative to a central body, but solving it requires sophisticated algorithms and a lot of processing power.

* Research
** Lambert
*** Problem
Lambert's Problem refers to the problem of determining a transfer orbit between two given position vectors (points in space) and a travel time between them. \cite{lambert_simple}
Lambert's Theorem states that the travel time along a Keplerian orbit between two points r_1 and r_2 is a function of \cite{lambert_izzo}:
- The distance between r_1 and r_2, $c$
- The sum of distances of r_1 and r_2 from the central body, $r_1+r_2$
- The semi-major axis of the orbit, $a$

No analytical solutions are known, but the problem can be solved via numerical approximations.

*** Solutions
The actual mathematics behind these is frankly a nightmare, but the concepts and intuition behind these solutions are interesting and worth explaining.

One common solution, as presented in \cite{lambert_simple} begins by defining the `fundamental ellipse', i.e the least-eccentric orbit which intersects points $r_1$ and $r_2$
Parameters of other solutions (i.e. other possible orbits), such as their eccentricity vector and argument of periapsis, can be defined in terms of their relation to this `fundamental ellipse'. For instance, the eccentricity vector $e$ can be represented as $e_F$ (i.e. $e$ of the fundamental ellipse) plus a transverse component $e_T$. Then, by iteratively varying $e_T$, we can approach an orbit which travels between $r_1$ and $r_2$ in the specified travel time.

One other solution, outlined in \cite{lambert_izzo}, involves defining a parameter $\lambda$, such that $s \lambda = \sqrt{r_1r_2}cos(\frac{\theta}{2})$, where s is the semiperimeter of the orbit. By defining new quantities $x$ and $y$, we can define an equation for the time period of an orbit in terms of these parameters, and use this as the basis for a differential equation to solve numerically.
This solution is the most popular to implement, and Poliastro (the python library I use) relies on a version of it.

** Gravity Assist
A Gravity Assist or `slingshot' maneuver involves using the gravitational field of a planet to effect a change in direction, i.e to supply delta-V. This can be used to achieve certain trajectories more cheaply.

Mathematically, we can model a gravity assist as a hyperbolic orbit, where we use asymptotes to an ellipse to represent trajectory vectors. \cite{assists_vassile}

A craft enters the planet's Sphere of Influence along an asymptotic arrival vector, and leaves along a `departure asymptote', with its orbit becoming a hyperbolic trajectory.

We know $V^2 = \mu (\frac{2}{r} - \frac{1}{a})$, from the conservation equation.
We can deduce the `hyperbolic excess velocity' of the body, i.e. the velocity of the body /relative to the planet/ as it exits the orbit, by having r \rightarrow \infty.
This yields $V_{\infty}=\sqrt{-\frac{\mu}{a}}$

The exit velocity (relative to the Sun) of the spacecraft is thus $V_2=V_{\infty}+V_p$, where V_p represents the velocity of the planet relative to the Sun.

If the angle of deflection between the entry and exit velocity vectors is $\psi$, then the delta-V of the spacecraft (including changes in direction) is \cite{assists_santos}:

$$\Delta V = 2 V_{\infty} sin(\frac{\psi}{2})$$

In order to maximise the change in velocity of the flyby, we should maximise the angle of deflection $\psi$, and minimise the flyby radius $r_p$.

#+DOWNLOADED: file:///home/rohan/d/indus-2/grav%20assist.png @ 2021-06-07 23:34:02
[[file:Research/2021-06-07_23-34-02_grav assist.png]]

In the diagram above, the object enters with hyperbolic velocity $V_{\infty}^-$ along the arrival asymptote, and exits with velocity $V_{\infty}^+$ along the departure asymptote.
$r_p$ denotes the point of closest approach (periapsis). The body follows a symmetric hyperbolic trajectory, so that the entry and exit asymptotes have related true anomalies \cite{assists_santos}.
The angle of deflection is related to the true anomaly of the body when it exits the planet's SOI (\theta_a): $\frac{\psi}{2}=\theta_a - \frac{\pi}{2}$

** Patched Conic Approximation
The Patched Conic Approximation is a method for getting approximate solutions to gravity assist maneuvers and other three-body problems. It divides the problem into three separate two-body problems - the initial planetocentric orbit, a heliocentric transfer orbit, and another planetocentric orbit (around the target planet), and defines `patch conditions', such as conditions on its velocity as it leaves the SOI (Sphere of Influence) of the first planet. \cite{aoe_conics}

Solving these problems usually involves defining 3 `patch points':

1. Conditions on leaving the first planet's SOI
2. Conditions arriving at the target planet
3. Conditions on leaving the target planet.

First, define vector quantities:
- $V_c$: Velocity of planet w.r.t Sun
- $V$: Heliocentric orbit velocity of the craft
- $\Delta V$: Difference between $V_c$ and $V$
- $\theta$: Angle between $V_c$ and $V$

By the cosine rule:
$$\Delta V_1^2 = V_{c_1}^2+V_1^2-2V_{c_1}V_1cos(\phi_1)$$
$$\Delta V_1^2 = V_{c_2}^2+V_2^2-2V_{c_2}V_1cos(\phi_2)$$

We can define some conditions on the body at the patch points.

We know that $\Delta V = V_{\infty}$, i.e. the velocity of the spacecraft relative to the planet is its excess hyperbolic velocity (which we already saw how to compute).

The velocity of the spacecraft relative to the sun is equal to the sum of the heliocentric velocity of the planet and the velocity of the spacecraft relative to the planet. Mathematically, $V_1=V_{\infty}+V_{c_1}$ \cite{ocw_17}

\beta , the `exit angle', is related to the relative magnitudes of V, V_1 and V_c_1, as well as the angle \phi between V and V_c.

Based on the exit velocity at infinity w.r.t planet 1, we can calculate the velocity at any other point in the orbit, enabling us to calculate the insertion velocity for planet 2.

$$\frac{V^2}{2}-\frac{\mu}{r}=\frac{V_{\infty}^2}{2} $$
Rearranging, $V^2 = V_{\infty}^2+\frac{2 \mu}{r}$

We assume the orbit is inserted into orbit around the second planet from a parking orbit at radius $r_pk$.

Applying the equation above and the cosine rule shows that the necessary delta-V is:

$$\Delta V^2 = V_{pk}^2+V^2_{c_{pk}}-2V_{pk}V_{c_{pk}}cos(\phi_{pk})$$
Where $V_{c_{pk}}=\sqrt{\frac{\mu}{r_{pk}}}$

** Voyager 2
Voyager 2 launched in 1977, and used gravity assists to perform a `grand tour' of all 4 outer planets and eventually exit the solar system.
Due to the gravity assists, Voyager 2 was able to maintain relatively high velocities, even while budgeting a total of about 190m/s of delta-V for maneuvers.

#+DOWNLOADED: file:///home/rohan/d/indus-2/voyager_trajectories.jpg @ 2021-06-07 12:46:48
[[file:Research/2021-06-07_12-46-48_voyager_trajectories.jpg]]


We can see that the gravity assists provided most of the delta-V for Voyager 2 by looking at the graph of its velocity relative to distance from the sun - each planetary flyby led to a spike in Voyager's velocity \cite{velocity_dist}.

#+DOWNLOADED: file:///home/rohan/d/indus-2/768px-Voyager_2_velocity_vs_distance_from_sun.svg.png @ 2021-06-07 15:35:21
[[file:Research/2021-06-07_15-35-21_768px-Voyager_2_velocity_vs_distance_from_sun.svg.png]]
*** Grand Tour
Voyager 2 took advantage of a rare planetary alignment (which occurs every 175 years) to go on a `Grand Tour' of the solar system, and visit all four outer planets, while Voyager 1 only visited Jupiter and Saturn before exiting the solar system. The reliance on gravity assists allowed this trajectory to be feasible, given constraints on delta-V, thrust, etc.
Voyager 2 provided the first flyby of Uranus and Neptune, and gathered exceptional data on things like the moons of Saturn and Jupiter.
*** Tracking and Attitude/Orientation
Voyager receives constantly transmitting waves from Earth, changes their frequency by a fixed ratio, and transmits it back to Earth. The craft's velocity can be measured from the change in frequency of waves received on Earth due to the doppler effect. \cite{backgrounder1980}

Voyager's distance from Earth can be measured by transmitting a digital code to Voyager and measuring the total time elapsed until it is returned. However, doing this accurately requires a sense of Voyager's velocity. \cite{backgrounder1980}


Celestial Reference: Electro-optical sensors view the Sun and the star Canopus. Data from these are fed to the automatic attitude/orientation adjustment system, allowing Voyager to automatically adjust its orientation around the three axes. \cite{backgrounder1980}

** Correctional Maneuvers
Trajectory Correction Maneuvers (TCMs) are performed before or after flybys, to correct for minor distortions caused by imperfect navigation, uncertainty in craft position/velocity, etc. Since these errors compound over time, periodic TCMs ensure the spacecraft stays on its intended trajectory. TCMs are usually on the order of magnitude of m/s, and most of the large maneuvers are in the form of unpowered gravity assists.

Voyager's Trajectory Correction Maneuvers relied on four small hydrazine thrusters, which were collectively able to exert about 0.5 pounds (2.224 Newtons) of thrust \cite{backgrounder1981}.

Voyager's flybys of Uranus and Neptune were the first flybys of the planet, and so data on the gravitational parameter (and on other factors, such as mass/radius of moons) was solely based on observation from Earth. Inaccuracies in the estimation/modelling due to this caused Voyager to deviate from the target orbit, and were dealt with via TCMs. \cite{od_jupiter}
Additionally, Voyager gained small amounts of delta-V due to orientation changes, such as to gather data or send out radiometric pulses. Similarly, voyagers roll thrusters (responsible for these changes in orientation) were slightly imbalanced, and so TCMs were used periodically to account for the effects of that \cite{od_uranus}

Voyager 2 executed a total of 20 TCMs, or about 5 per flyby. Most of these TCMs happened shortly (on the order of a few months or less) before or after flybys.

TCMs were reconstructed in a series of papers by R.A Jacobson based on three main data sources:
1. Voyager radiometric tracking: Having Voyager send radio waves of a known frequency back to Earth, and using the doppler effect to deduce its distance from Earth and velocity.
2. Optical navigation data: Comparing the data from Voyager's cameras/sensors to visual data of star backgrounds, etc.
3. Satellite astrometry: Observing the relative position of Voyager 2 to satellites, planets, and other celestial bodies from various observatories, and cross-referencing the data to get an approximation of its position in space.

The orbit reconstruction relied on a dynamic force model, including the gravitational forces of moons, and non-gravitational forces such as solar radiation pressure and thruster imbalances on the Voyager craft.

** Oberth Effect
The Oberth effect is a phenomenon where a small impulse can create a large change in kinetic energy, if the initial velocity is high enough. In space travel, this means that if a burn is fired at (or centered around) periapsis, it can increase the kinetic energy, giving the craft additional hyperbolic velocity and allowing it to exit the planet's Sphere of Influence. Intuitively, this arises from the fact that firing a burn at periapsis results in both the chemical and mechanical energy of the fuel being converted to kinetic energy for the rocket. \cite{aapt_oberth}
Mathematically,
$$ \Delta K_r = \frac{1}{2}M(v+\Delta v)^2 - \frac{1}{2}M(\delta v)^2 $$
$$ \Delta K_r = \frac{1}{2}M(\Delta v)^2 + Mv\Delta v $$
And so we see the change in kinetic energy increases with the (initial) velocity of the spacecraft. Thus, the rocket gains more kinetic energy from the same impulse when it is already moving at a high velocity.

When firing a burn, the exhaust has speed v_{ex}-v relative to the planet.
he change in KE (of the expelled fuel) is $\frac{1}{2} m_{ex}(v_{ex}-v)^2-\frac{1}{2}m_{ex}v^2$

We can imagine this as a rocket-powered skateboard travelling along a U-shaped valley. At the starting point, the rocket and fuel together have a total energy of -(M+m_{ex})gh_A , where h_A is the height of point A (since velocity is 0, all energy is in the form of GPE).

If the rocket fires a burn at the trough B, while moving with velocity v_B, then:

The energy of the rocket is $E_r = \frac{1}{2}M(v_B+\Delta v)^2 - Mgh_B = \frac{1}{2}M(\Delta v)^2 + Mv_B \Delta v + \frac{1}{2}Mv_B^2-Mgh_B$

Thus, we see the rocket gains kinetic energy $\frac{1}{2}M(\Delta v)^2 + Mv_B \Delta v$ due to the burn.

The energy of the exhaust is $E_{ex} = \frac{1}{2}m_{ex}(v_b-v_{ex})^2-m_{ex}gh_b = \frac{1}{2}m_{ex}v_{ex}^2 - m_{ex}v_B + \frac{1}{2}m_{ex}v_B^2 - m_{ex}gh_B$

Thus, we see the exhaust /loses/ kinetic energy $\frac{1}{2}m_{ex}v_{ex}^2 + m_{ex}v_B$, meaning the total energy of the system remains constant.

With the Oberth effect, a burn fired at periapsis has a similar effect - by firing the burn at a relatively high velocity, the rocket benefits from both the mechanical and chemical energy of the fuel, and thus is able to reach a higher final velocity.

* Practice
** Experimentation
*** PyKep \cite{pykep}
PyKep is a scientific library that allows us to model space exploration missions (such as multiple gravity assist maneuvers) as optimisation problems, and solve them using genetic algorithms and other optimisation techniques.
However, PyKep has limited ability to define constraints and specifications (such as on the specific energy $C_3$ of the craft, and on how precisely we can define orbit timelines)
*** Poliastro \cite{poliastro_software}
Poliastro is a library for simulating and visualising orbital mechanics, sponsored by Google and the ESA.
It provides facilities for plotting planets and other bodies over time, including propagating spacecraft orbits, as well as for automatically defining transfer orbits and maneuvers based on Lambert solvers.
Ultimately, this was the one I settled on. It was the best-documented and easiest to work with, and also the only software under active development.
** Notes on Poliastro Implementation
In order to model the planned Voyager 3 mission, I used the python library Poliastro. It provides automated utilities for modelling and graphing orbits.
Poliastro includes functions for automatically solving Lambert problems, and simulating gravity assists.
*** Lambert
Central to Poliastro is the algorithm for solving Lambert's Problem, based on the solution in \cite{lambert_izzo}. In this implementation, it also calculates the delta-V necessary to achieve the required transfer orbit, and the initial and final velocity vectors.

*** Patched Conics
Poliastro also uses patched conics computations to achieve higher accuracy in gravity assists and other multi-planet maneuvers \cite{Poliastro_conics}.

Poliastro uses patched conic methods to calculate the delta-V gained from unpowered flybys, depending on input parameters like the hyperbolic insertion velocity, the radius of the flyby orbit, etc.

*** Automatic Gravity Assists
\cite{Poliastro_jupiter} demonstrates a sample Poliastro mission which performs a gravity assist around Earth to reach Jupiter, without us needing to explicitly program parameters for the assist. The mission is based on the New Horizons Juno probe.

Poliastro's Lambert solver is `aware' of the gravitational influence of the planet, and automatically performs gravity assists. As a result, we need simply define the initial and target orbits for poliastrio to model a gravity assist.

#+begin_src python
# And now, go to Jupiter!
jupiter = Ephem.from_body(Jupiter, time_range(date_launch, end=date_arrival))

ss_j = Orbit.from_ephem(Sun, jupiter, date_arrival)
# Solving for maneuver to Jupiter
man_jupiter = Maneuver.lambert(ic2_end, ss_j)
imp_a, imp_b = man_jupiter.impulses

print("Initial impulse:", imp_a)
print("Final impulse:", imp_b)
#+end_src

*** Force Models/Propagation
Poliastro's propagation system has two elements - a numerical solver for Kepler's equation, and various (mostly analytical) functions for calculating the effects of perturbations.

*Kepler's Equation*
The default Keplerian solver - the Farnocchia algorithm - is based on the Keplerian elements. It calculates the change in anomaly between the start and end times, depending on the pericenter distance $q=\frac{p}{1+e}$, and on the nature of the orbit (such as whether it is elliptical, parabolic, or hyperbolic).

Poliastro also provides other propagation mechanisms, such as Vallado's algorithm and Danby's method.

Vallado's algorithm formulates the problem in terms of a universal variable $\chi$ and returns Lagrange Coefficients $f$ and $g$, and their derivatives $\dot{f}$ and $\dot{g}.
We can use these to calculate the final $r$ and $v$ vectors as follows:
$$\vec{r} &= f\vec{r_{o}} + g\vec{v_{o}} \\
\vec{v} &= \dot{f}\vec{r_{o}} + \dot{g}\vec{v_{o}} $$

Danby's model defines the Keplerian equation as a function $x=M+e\sin{x}$, and uses Aitken's delta method (an improvement on Newton's method, which converges more quickly) to find the root of the equation.
It assumes a random x_n, and assumes $x_n+\epsilon_n = a$ where a is the root of the equation. Then, the method involves a Taylor expansion around $a$, and expressing that in terms of x_n and \epsilon_n to get a polynomial approximation of the equation, using that to find the root.

*Perturbations*
Poliastro's perturbation model includes J2 and J3 functions, as well as third-body perturbations and radiation pressure functions.

J2 and J3 are included as general functions, calculated based on the oblateness of the attractor and its mass/radius. It yields acceleration caused by J2/3 perturbations as a vector. Included generally, so calculates perturbations for Jupiter, etc. automatically.

The third-body function takes parameters ~k~ (grav param of third body) and ~pos~, a function describing the position of the third body as a function of time, and calculates the acceleration vector using the standard third-body perturbation equation. However, it disregards factors such as obliquity, and so isn't entirely accurate.

# TODO: Cite polaistro sources, farnocchia, etc.

** Plotting Planets
For an intuitive overview of the Voyager 3 mission, I created a plot of the planets at various points. Based on the Voyager 2 mission timelines, I plotted the planets at the points they would be when Voyager 3 arrives at them.

Poliastro provides facilities for plotting orbits of planetary bodies. I defined a function to plot planets at specific time offsets.

I learned that a Voyager 3 mission would only be able to visit 3 planets - Jupiter, Uranus, and Neptune, rather than doing a full grand tour.
*** Code Snippets
#+begin_src python
def plot_planet(planet, duration, start=launch, plotter=plotter):
    plotter.plot_body_orbit(
        planet, start + years(duration), label=f"{planet} at time of flyby"
    )


def plot_all(start=launch, plotter=plotter):
    plot_planet(Earth, 0, start, plotter)
    plot_planet(Jupiter, 2, start, plotter)
    plot_planet(Saturn, 4, start, plotter)
    plot_planet(Uranus, 9.5, start, plotter)
    plot_planet(Neptune, 13, start, plotter)


def multiple(start=launch, inc=3, it=8):
    for i in range(0, it):
        start += months(inc)
        plot_all(start, StaticOrbitPlotter())
#+end_src
*** Output Plot
#+DOWNLOADED: file:///home/rohan/d/indus-2/planet%20positions%202024%20launch.png @ 2021-06-07 12:46:00
[[file:Practice/2021-06-07_12-46-00_planet positions 2024 launch.png]]
** Plotting 1977 Mission
In order to come up with a template for the 2024 mission, I decided to first model the 1977 mission. This way I'd be able to check my simulation against existing data.
The program was based on the example given in \cite{Poliastro_jupiter}
*** Overview of Program
The program defines a generic ~assist_to_planet()~ function, which does the following. Calling this function with different planets and parameters (such as target dates) lets us simulate a deep-space mission with multiple gravity assists.
1. Generate ephemeris of the target planet around launch/arrival times
2. Convert that ephemeris to a heliocentric orbit
3. Have the program calculate a Lambert maneuver from the current orbit to the point of closes approach of the target planet (such that it arrives at that point at the correct epoch)
4. Propagate that maneuver forward to the epoch of closest approach
5. Compute and return the impulses and total delta-V cost (including delta-V from gravity assist) of that maneuver.
6. Also return the resulting orbit around the planet that the body has transferred into.
7. Plot that maneuver on a ~StaticOrbitPlotter~.
*** ~Assist to planet~ function
#+begin_src python
def assist_to_planet(planet, arrival, current, color):
    planet_orbit = Ephem.from_body(
        planet, time_range(launch_date, end=arrival + TimeDelta(1 * u.yr))
    )
    ss = Orbit.from_ephem(Sun, planet_orbit, arrival)
    man = Maneuver.lambert(current, ss)
    (flyby, _) = current.apply_maneuver(man, intermediate=True)
    flyby_end = flyby.propagate(arrival + TimeDelta(0 * u.wk))
    plotter.plot_body_orbit(planet, arrival, label=f"{planet} Time of Flyby")
    plotter.plot_trajectory(
        flyby_end.sample(min_anomaly=flyby.nu, max_anomaly=flyby_end.nu),
        label=f"To {planet}",
        color=color,
    )
    return (
        flyby_end,
        man.get_total_cost(),
    )
#+end_src
*** Initial Orbit
I started by defining the C_3 (characteristic energy in $m^2/s^2$) of the voyager 2 craft, and also the initial orbit of voyager 2.
The initial orbit was defined based on ephemeris data from the JPL Horizons database.
#+begin_src python
init_orbit = Orbit.from_classical(
    Sun,
    3.76054 * u.AU,
    0.733305558 * u.one,
    4.87003 * u.deg,
    327.8026 * u.deg,
    11.65107 * u.deg,
    348.80709 * u.deg,
)
#+end_src
*** Outputs
The program is able to calculate and output the radius and velocity vectors of the simulated craft over time, as well as the total delta-V caused by maneuvers.
**** Code to generate outputs:
#+begin_src python
def magnitude(obj):
    return (norm(obj.rv()[0]).to(u.AU), norm(obj.rv()[1]))

vectors = [
    magnitude(init_orbit),
    magnitude(jupiter_end),
    magnitude(saturn_end),
    magnitude(uranus_end),
    magnitude(neptune_end),
]

pprint(vectors)
print()
pprint(f"Jupiter: {jupiter_cost}")
pprint(f"Saturn: {saturn_cost}")
pprint(f"Uranus: {uranus_cost}")
pprint(f"Neptune: {neptune_cost}")
#+end_src
**** Distance from sun (magnitude, AU) and Velocity (magnitude, km/s) at various points:
#+begin_src
[(<Quantity 1.01105114 AU>, <Quantity 38.97381359 km / s>),
 (<Quantity 5.32385823 AU>, <Quantity 12.77382399 km / s>),
 (<Quantity 9.59257842 AU>, <Quantity 15.43820498 km / s>),
 (<Quantity 19.11545267 AU>, <Quantity 17.8635083 km / s>),
 (<Quantity 30.2129865 AU>, <Quantity 18.84014064 km / s>)]
#+end_src
**** $\Delta v$ from flybys (this includes the $\Delta v$ gained from gravity assists:
#+begin_src
'Jupiter: 19.224017095758576 km / s'
'Saturn: 24.659315822167006 km / s'
'Uranus: 29.304008812446888 km / s'
'Neptune: 22.613330589378773 km / s'
#+end_src
*** Plot Produced
#+DOWNLOADED: file:///home/rohan/d/indus-2/voyager%202.png @ 2021-06-07 12:44:01
[[file:Practice/2021-06-07_12-44-01_voyager 2.png]]

** Checking Against Voyager 2
Due to some uncertainties I had about the results of my original simulation, I tried to verify them against known records for the voyager spacecraft.

Poliastro also provides methods for querying ephemeris files (which record orbit information for missions such as voyager 2) and analysing them \cite{Poliastro_ephem}. I wrote a script to query these ephemeris files for voyager 2, and retrieve the delta-V of the various burns and gravity assists.

The script essentially samples the velocity vectors at evenly-spaced points in time, and compares them. The function vsub returns the delta-V between two intervals, both as a vector and as a scalar (the magnitude of the delta-V vector).

My original simulation also outputs the delta-V caused by the various flybys I simulated. By comparing the data from my own simulation with this ephemeris data, I was able to spot and solve various errors.
*** Jupiter
#+begin_src
In [49]: vsub(47,45)
Out[49]:
(<Quantity [-11.05536094,  -9.61441214,  -2.31458803] km / s>,
 <Quantity 14.83291084 km / s>)
#+end_src
*** Saturn
#+begin_src
In [58]: vsub(100,98)
Out[58]:
(<Quantity [12.79594337, -7.24734966, -4.27395355] km / s>,
 <Quantity 15.31427187 km / s>)
#+end_src
*** Uranus
#+begin_src
In [68]: vsub(210,208)
Out[68]:
(<Quantity [5.63390722, 0.77951089, 1.58976787] km / s>,
 <Quantity 5.90558292 km / s>)
#+end_src
*** Neptune
#+begin_src
In [74]: vsub(299,297)
Out[74]:
(<Quantity [ -8.13444399,   7.73798519, -10.31194071] km / s>,
 <Quantity 15.24407147 km / s>)
#+end_src

These diverged significantly from the results of my script (which I've included below)
#+begin_src
'Jupiter: 19.224017095758576 km / s'

'Saturn: 24.659315822167006 km / s'

'Uranus: 29.304008812446888 km / s'

'Neptune: 22.613330589378773 km / s'
#+end_src

** Correction Maneuvers from Ephemeris and Mission Reports
Poliastro is incapable of automatically generating correctional maneuvers, which are necessary to ensure that the trajectory is maximally efficient. I implemented TCMs in Poliastro based on orbit determination papers \cite{icrf_jupiter} \cite{icrf_saturn} \cite{icrf_neptune}, which recorded the time and delta-V of Voyager 2's correctional maneuvers.
Since some of the data was lacking, I cross-referenced it with voyager ephemeris data from the JPL horizons system, which recorded the velocity vectors at different points in time. I wrote a python script to parse these ephemeris files, which could calculate the delta-V between various points in time and identify patterns which matched maneuvers (such as a short period of time with delta-V higher than average, or an impulsive maneuver which caused a large near-instantaneous change in velocity).
By selecting certain ranges of ephemeris files, I was able to find the delta-V of most of Voyager's TCMs.

In order to implement these in my simulation, I created a hashtable of maneuvers, each associated with a name (the hashtable key), an epoch, and an impulse (both of which were stored in a tuple).
I also redefined the ~assist_to_planet~ function, to automatically fire these maneuvers at the appropriate epoch. I defined a routine to search through that hashtable to find maneuvers associated with dates within a certain time range, and to interrupt the orbit propagation to fire those burns.
*** Code Snippets
**** Sample of a maneuver, represented as a hashtable entry
#+begin_src python
"04": (
    maneuver([563.738, 522.016, 29.424] * u.mm / u.s),
    time("1979-06-27 10:09:09", scale="utc").tdb,
),
#+end_src
**** Function to retrieve all impulses for the current section of the mission
#+begin_src python
def impulses(date, current, mans=tcm()):
    # Get all impulses between end of current orbit and target dat
    return [i for i in mans.values() if current.epoch < i[1] < date]
#+end_src
**** Subroutine to apply impulses sequentially during flyby
#+begin_src python
flyby, target = current.apply_maneuver(man, intermediate=True)
for i in impulses(arrival, current):
    flyby.propagate(i[1])
    (flyby,) = flyby.apply_maneuver(i[0], intermediate=True)
#+end_src
**** Ephemeris Generator
#+begin_src python
def gen_ephem(orbit, start):
    # Output RV vectors over time
    init = orbit.propagate(start)
    final = orbit.propagate(start + TimeDelta(1 * u.d))
    data = orbit.sample(values=24, min_anomaly=init.nu, max_anomaly=final.nu)
    return data, data.differentials["s"]  # Position in km, vel in km/s
#+end_src
**** Outputs
#+begin_src
[(<Quantity 1.01105114 AU>, <Quantity 38.97381359 km / s>),
 (<Quantity 5.32412652 AU>, <Quantity 12.77467893 km / s>),
 (<Quantity 9.58900767 AU>, <Quantity 15.43777008 km / s>),
 (<Quantity 19.11545267 AU>, <Quantity 17.85828753 km / s>),
 (<Quantity 30.21376221 AU>, <Quantity 18.84055891 km / s>)]


'Jupiter: 19.224017096185012 km / s'
'Saturn: 24.662460566215962 km / s'
'Uranus: 29.28157445966514 km / s'
'Neptune: 22.617026306586364 km / s'
#+end_src
** Plotting 2024 Mission: Initial Attempt
Based on the results of this simulation, I wrote a script to simulate a similar mission which launched in or near 2024. The script uses similar functions, but it only visits a few planets.
*** Defining Initial Orbit
Since there weren't any ephemeris files I could rely on, I defined the initial orbit to be a Geosynchronous Transfer Orbit. Such an orbit has an apogee radius of about 42000km, and a perigee radius of about 6600km \cite{planetary_soc_gto}.
I calculated the necessary Keplerian orbital elements (required to define an orbit in Poliastro) as follows:

$$a = \frac{r_{ap}+r_{per}}{2}=24582$$

$$ecc= \frac{r_{ap} - r_{per}}{r_{ap} + r_{per}} =0.73033754$$

I used the sun as the center of the orbit using the ~change_attractor~ method in order to measure heliocentric rather than geocentric velocity.
With this, the body left Earth's orbit with excess (heliocentric) hyperbolic velocity of about 38km/s - similar to what Voyager 2 started with.
#+begin_src python
init_orbit= Orbit.from_classical(
    Earth,
    24582*u.km, # Semi-major Axis
    0.7303*u.one, # Eccentricity
    19.3*u.deg, # Inclination
    0*u.deg, # RAAN
    0*u.deg, # Argument of Pericenter
    0*u.deg, # True Anomaly
    epoch=launch_date
).change_attractor(Sun)
#+end_src
#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/ESA GTO.png @ 2021-06-29 17:18:31
[[file:Practice/2021-06-29_17-18-31_ESA GTO.png]]
\cite{ESAGeost}
*** Initial Results
Poliastro produced a slightly unusual plot for this mission: Rather than flying directly from Jupiter to Uranus, the solution it produced involved multiple revolutions. It traveled to Jupiter, and performed a gravity assist there that caused it to return to (and swing by past) Earth on its way to Uranus, only to return to Earth and swing around to Neptune.

#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/voyager-2024-proper.png @ 2021-07-02 09:56:31
[[file:Practice/2021-07-02_09-56-31_voyager-2024-proper.png]]

As a sanity check, I compared the data from this simulation to the (verified and accurate) data from the Voyager-2 simulation.
#+begin_src
// Total velocity change due to gravity assist (2026):
'Jupiter: 25.12748186373011 km / s'
'Uranus: 28.14334237600722 km / s'

// Total velocity change due to gravity assist (Voyager-2):
'Jupiter: 19.224017096185012 km / s'
'Saturn: 24.662460566215962 km / s'
'Uranus: 29.270080992361287 km / s'
'Neptune: 22.622330767345026 km / s'
#+end_src

We can see that although the numbers are different, they are within the same range of around 20-30km/s delta-V, indicating that these results are reasonable rather than outlandish. Additionally, we can see that the values for Uranus are higher than for Jupiter, in line with the Voyager 2 data (and with our intuitions, since the `deflection' at Uranus is visibly larger.

Despite this, an orbit such as this one seemed like it might complicate other aspects of the mission, even if this preliminary analysis made it seem feasible. For instance, I would speculate (inexpertly) that the body intersects with the SOI of Earth and other planets during its flight, which may introduce third-body perturbations that require expensive TCMs to correct for.
# Additionally, we can see that the trajectory, despite its unusual shape, matches the timelines we prescribed. Thus, given that the delta-V figures and timelines are in line with expectations, I've concluded that this trajectory is a viable one for a future voyager-3 mission.
** Verifying the 2024 Solution
Since this plot was unexpected, to say the least, I decided to perform some tests to see if it was genuinely the optimal solution, or the result of irregularities in my design.

I experimented with varying the launch epoch over a large time range to see what effect that had on results.
*** Programatically Varying the Launch Time
I wanted to see if this was the result of an unusual choice of launch epoch. To test this, I coded a feature to consistently vary all the launch/arrival dates, in 3-month increments over a 5-year period from 2024 to 2029. This produced a wide range of plots, but they all shared the common feature of looping around Earth after performing their gravity assists.
#+begin_src python
  dates = {"launch": Time("2024-01-01", scale="utc").tdb,
           "jupiter": Time("2026-01-01", scale="utc").tdb,
           "uranus": Time("2033-01-01", scale="utc").tdb,
           "neptune": Time("2036-01-01", scale="utc").tdb,}

  for i in range(20):
      for k in dates.keys():
          dates[k] = dates[k] + TimeDelta(12 * u.wk)
      # Main code went here
#+end_src
*** Comparing to Ephemeris Files
I also wrote a script that compared the positions of Jupiter and Uranus (relative to the Earth) from 2024 onward to their positions at the time of the Voyager 2 flyby. I noticed that the time which was most similar to the times of flyby were April 2026 for Jupiter, and December 2043 for Uranus.

However, even then the position vectors were very different from the position vectors at the time of the original flyby. Based on this, I concluded that my errors were partly in the choice of planets to visit, and began to explore different planets to visit. This eventually led me to my solution, of finding a working trajectory that visited Saturn and Uranus.

#+begin_src python
  def closest_r(data, const): #
      Find epoch/rv of object which is closest to the position vector const
      diffs=[vdiff(const, i.r) for i in data]
      idx=diffs.index(min(diffs))
      return data[idx]

  voy2_jup=datapoint.from_lines("2443325.500000000 = A.D. 1977-Jul-01 00:00:00.0000 TDB",
                                "X = 1.551783168059400E+08 Y = 8.877133948602245E+08 Z =-7.056679235727489E+06",
                                "VX=-4.175487351667007E+01 VY=-1.028913798527010E+00 VZ= 2.726943920685317E-01"
                                )


  voy2_ur= datapoint.from_lines("2446451.500000000 = A.D. 1986-Jan-21 00:00:00.0000 TDB",
                                "X =-4.754062367113435E+08 Y =-2.933414590935786E+09 Z =-3.268767410831213E+06",
                                "VX= 3.295603995565554E+01 VY= 1.347721156523741E+01 VZ= 3.656038905200099E-02"
                                )

  ds_jup=from_file("/Users/rohangoyal/Downloads/jupiter 2024.txt")
  ds_ur=from_file("/Users/rohangoyal/Downloads/uranus 2034.txt")
#+end_src

#+begin_src
# NOTE: The array represents the position vector of the planet in kilometers.

In [1]: voy2_jup
Out[1]: ['1977-07-01T00:00:00', array([ 1.55178317e+11,  8.87713395e+11, -7.05667924e+09])]

In [2]: closest_r(ds_jup,voy2_jup.r)
Out[2]: ['2026-04-01T00:00:00', array([-2.01609233e+11,  7.31228899e+11,  4.87158347e+09])]

In [3]: voy2_ur
Out[3]: ['1986-01-21T00:00:00', array([-4.75406237e+11, -2.93341459e+12, -3.26876741e+09])]

In [4]: closest_r(ds_ur,voy2_ur.r)
Out[4]: ['2043-12-01T00:00:00', array([-2.12049235e+12,  1.68400804e+12,  3.35241341e+10])]
#+end_src

** Finding a Better Solution
First, I refactored my code to make it easier to define and test out new missions. I automated the calculation of flyby dates based on a specified launch date and the method of plotting and outputting delta-V for arbitrary planets.
#+begin_src python
# Specify dates
dates = od(
    {
        Earth: launch,
        Jupiter: launch + TimeDelta(2 * u.yr),
        Saturn: launch + TimeDelta(4 * u.yr),
        Uranus: launch + TimeDelta(9.5 * u.yr),
        Neptune: launch + TimeDelta(12 * u.yr),
    }
)
#+end_src

#+begin_src python
for i in planets:
    ends[i], costs[i] = assist_to_planet(
        i, dates[i], list(ends.values())[-1], f"C{len(ends)}"
    )

pprint(costs)
pprint([f"{i}:{magnitude(v)}" for i, v in ends.items()])
#+end_src

After that, I also plotted the planets over a wider time range, to look for points in time where planets were (or were very nearly) aligned. Running this simulation, I noticed some common patterns. Neptune was never aligned with any of the other planets, so the only possible options were Jupiter, Saturn, and Uranus. I noticed that if the mission launched in 2030, Saturn in 2034 (roughly the time we'd expect to fly by it) was almost perfectly in line with Uranus in 2039.

#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/saturn 2030-proper.png @ 2021-07-07 11:55:03
[[file:Practice/2021-07-07_11-55-03_saturn 2030-proper.png]]
*** Final Results
I experimented with running a mission based on these parameters:
#+begin_src python
plotter = StaticOrbitPlotter()
launchdate = Time("2030-04-01", scale="utc").tdb
run_mission(launchdate, [Saturn, Uranus])
#+end_src

The mission proved in line with my expectations - the delta-V values from the gravity assists was in line with my expectations based on Voyager 2, and the plot looked more feasible than my initial results. The results are reproduced below:
#+begin_src
OrderedDict([(Saturn (♄), <Quantity 21.40313459 km / s>),
             (Uranus (⛢), <Quantity 15.64565391 km / s>)])
['Earth (♁):(<Quantity 0.83475772 AU>, <Quantity 32.89821287 km / s>)',
 'Saturn (♄):(<Quantity 9.03771884 AU>, <Quantity 6.15086829 km / s>)',
 'Uranus (⛢):(<Quantity 18.59945636 AU>, <Quantity 6.30082048 km / s>)']
#+end_src

#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/voy-2030-saturn.png @ 2021-07-07 12:03:40
[[file:Practice/2021-07-07_12-03-40_voy-2030-saturn.png]]

* Problems and Open Questions
** Delta-V Mismatch
When comparing the results from the ephemeris to my simulation, I noticed an odd error. Although the rv (radius and velocity) vectors output by the simulation roughly matched the ephemeris, the delta-V due to gravity assists did not match existing data.

The delta-V errors accumulated over time, but the mismatch was small enough that it could be caused by relatively minor inaccuracies in the simulation.

The source of this problem was the lack of trajectory correction maneuvers, which led to the simulated trajectory diverging from the actual voyager 2 trajectory. In order to solve it, I introduced a routine to automatically perform trajectory correction maneuvers at the appropriate epoch, with the delta-V and duration defined based on orbit determination data for the original voyager.

** Calculating Delta-V
Poliastro does not separate delta-V due to maneuvers from delta-V caused by flybys. Additionally, it is unable to model constraints such as delta-V budgets, or thruster power (at least as far as I can tell).

Poliastro defines a method ~get_total_cost~ which returns the total delta-V caused by the maneuver, including the delta-V gained by the slingshot. In order to cross-check the simulation with the voyager flight data, I relied on looking at instantaneous velocity at various critical points (just before, just after, and during flybys).

Since correctional maneuvers happened before gravity assists rather than in tandem, I was able to verify the delta-V costs of those, and check that they conformed to the delta-V budget of Voyager 2.

** Imperfections in Final Result
The solution defined here is only the high-level first-stage solution - refinements will depend on factors such as the kinds of scientific experiments planned for the craft, and the physical nature of the craft (such as its delta-V budget, mass, surface area, etc.).

For instance, with Voyager 2 TCMs were used to account for uncertainty in gravitational parameters, and for orientation/velocity changes due to scientific investigations. Thus, TCMs for this mission can only be modelled at a later stage, and can be ignored for now.

Additionally, factors such as the craft's surface area may mean that perturbations such as solar radiation pressure are more or less significant, which may necessitate small changes in the trajectory, or application of TCMs.

However, as the first step in mission planning, and as an approximate solution, the results I've simulated are perfectly feasible, and serve their purpose.

** Open Questions
Although I was able to accomplish the objective and calculate a trajectory, a variety of open questions remain. This is a list of problems I had to work around rather than solve, as well as of related questions that I was unable to answer.

One question is how to reverse orbit directions within poliastro, and more generally how to constrain the solutions poliastro looks through. I experimented with varying the RAAN and inclination of the orbit, but that had no effect on the solutions.

Another theoretical question relates to the feasibility of the original 2026 mission. The timelines and delta-V seemed to work out, but the orbit seems likely to create new complications - it would be interesting to learn whether that's true, and what those complications might be.

I was unable to specify spacecraft data, such as their specific impulse and dry mass - Poliastro provides a spacecraft class where we can specify factors such as mass and surface area, but it doesn't allow us to pass these objects to propagation or maneuver commands. I wasn't able to encode this data in the simulation, which might have contributed to inaccuracies in the results.
# TODO: Cite spacecraft class
#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/voyager-2024-proper.png @ 2021-07-02 09:56:31
[[file:Practice/2021-07-02_09-56-31_voyager-2024-proper.png]]

- Reverse direction
- Imperfections in poliastro
- Constraints created by the first attempt at 2024.
* Conclusion
To summarise, we began by simulating a Voyager 2 mission in python using poliastro. After that, I verified the results against the original Voyager 2 data, and made various changes to the script to improve the accuracy of the simulation.

Using this new script as a template, I simulated a Voyager 3 mission launching in or after 2024. When that produced (initially) unsatisfactory results, I modified the program based on other simulations and research, eventually settling on a feasible solution (which is reproduced below).

#+begin_src python
plotter = StaticOrbitPlotter()
launchdate = Time("2030-04-01", scale="utc").tdb
run_mission(launchdate, [Saturn, Uranus])
#+end_src

#+begin_src
OrderedDict([(Saturn (♄), <Quantity 21.40313459 km / s>),
             (Uranus (⛢), <Quantity 15.64565391 km / s>)])
['Earth (♁):(<Quantity 0.83475772 AU>, <Quantity 32.89821287 km / s>)',
 'Saturn (♄):(<Quantity 9.03771884 AU>, <Quantity 6.15086829 km / s>)',
 'Uranus (⛢):(<Quantity 18.59945636 AU>, <Quantity 6.30082048 km / s>)']
#+end_src

#+DOWNLOADED: file:/Users/rohangoyal/OneDrive/School/indus-2/voy-2030-saturn.png @ 2021-07-07 12:33:00
[[file:Conclusion/2021-07-07_12-33-00_voy-2030-saturn.png]]

* COMMENT Crud
- research on voy maneuvers and elta-v ({planet} orbit.pdf)
- stone{date}.pdf
- voyager backgrounder, mission description
- ** COMMENT Unexpected Results
Final simulation showed it was impossible to visit Neptune, meaning only Jupiter and Uranus were possible.
It also gave an unexpected plot for the mission, showing a multi-revolution solution which involved completing nearly a full orbit around Jupiter, rather than going straight to Uranus.

Despite this, the numbers Poliastro calculated for values such as the spacecrafts heliocentric velocity and delta-V were more or less in line with what I expected based on the voyager 2 data.

*** Distance and Velocity (Heliocentric) Snapshots
#+begin_src
[(<Quantity 0.98327695 AU>, <Quantity 29.93678845 km / s>),
 (<Quantity 5.3852182 AU>, <Quantity 5.77279585 km / s>),
 (<Quantity 18.9796682 AU>, <Quantity 13.75296829 km / s>)]
#+end_src

*** Delta-V from Flybys
#+begin_src
'Jupiter: 27.123995291855735 km / s'
'Uranus: 34.65363008982447 km / s'
#+end_src
*** COMMENT Science and Research
- Atmospheric composition of planets and moons
- Visual reconnaissance
- Analysing planet magnetic fields

* Appendix: List of Relevant Files
- ~2026-mission.py~: The source file for simulating the 2026 Voyager 3 mission, and producing data/plots
- ~voy-2026-plot.png~: Plot of the calculated 2026 Voyager 3 trajectory, produced by the ~2026-mission.py~ script
- ~time-variations.pdf~: Contains various plots of hypothetical Voyager 3 missions, starting at different launch times.
- ~voyager-2.py~: Simulation of the original voyager mission
- ~voy-2-plot.png~: Plot of voyager 2 trajectory, produced by ~voyager-2.py~ script
- ~plot-planets.py~: Produces a plot of each planet at the position it is expected to be in when Voyager 3 flies by it (assumes 2024 launch, so approximate at best)
- ~planet-positions.png~: Plot produced by ~plot-planets.py~
- ~ephem-parser.py~: A set of tools for automatically processing ephemeris files, which list positions and/or velocities of bodies over time in a specified format
* Bibliography
\bibliographystyle{plain}
\bibliography{full-bibliography}
